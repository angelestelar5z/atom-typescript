'scopeName': 'source.ts'
'comment': 'TypeScript Syntax: version 1.0'
'fileTypes': [
  'ts'
  'str'
  'tst'
]
'name': 'TypeScript'

'patterns': [
  # TODO highlight for vars, etc...
  # FIXME Unicode shizzle
  # FIXME (Inline) comments break everything
  # IDEA highlight void differently?
  # TODO normal function definitions
  # TODO match function arguments
  {
    'comment': 'Match stuff like: namespace name {...}'
    'match': '\\b(module|namespace)\\s+(\\s*[a-zA-Z0-9_?.$][\\w?.$]*)\\s*'
    'name': 'meta.function.ts'
    'captures':
      '1':
        'name': 'keyword.other.ts'
      '2':
        'name': 'entity.name.module.ts'
  }
  {
    'comment': 'Match this.'
    'match': '\\b(this)\\b'
    'captures':
      '1':
        'name': 'storage.type.variable.ts'
  }
  {
    'begin': '(?<=interface|class)'
    'end': '}'
    'patterns': [
      # TODO Normal function definitions in here (and outside)
      {
        # Grammar rule originally taken from JavaScript grammar, but heavily modified (https://github.com/atom/language-javascript/blob/517019cdc8e9114b13c2edcebf4ec49cf27e7a64/grammars/javascript.cson#L263-L279)
        'begin': '\\G\\s+([\\w$]+(?:\\.[\\w$]*)?(?:<[\\w$]+(?:\\s*,\\s*[\\w$]+)*>)?)?(?:\\s+(extends)\\s)?'
        'beginCaptures':
          '1':
            'patterns': [
              {
                'match': '\\w+'
                'name': 'meta.class.ts'
              }
              {
                'match': ','
                'name': 'meta.delimiter.object.comma.js'
              }
            ]
          '2':
            'name': 'storage.modifier.ts'
        'end': '(?<!extends\\s)\\s*{'
        'patterns': [
          {
            'include': '#type'
          }
        ]
        'contentName': 'meta.inherited-from.ts'
      }
      {
        'comment': 'Matches class method names and styles as function, even if marked private, or getters/setters'
        'begin': '^\\s*(?:(private)\\s+)?(\\w*)<'
        'beginCaptures':
          '1':
            'name': 'keyword.other.ts'
          '2':
            'name': 'entity.name.function.ts'
        'end': '>(?=\\()'
        'patterns': [
          {
            'include': '#type'
          }
          {
            'match': 'extends'
            'name': 'storage.type.modifier.ts'
          }
        ]
      }
      {
        'match': '^\\s*(?:(private)\\s+)?(?:(get|set)\\s+)?(\\w+)(?=\\()'
        'captures':
          '1':
            'name': 'keyword.other.ts'
          '2':
            'name': 'storage.modifier.ts'
          '3':
            'name': 'entity.name.function.ts'
      }
      {
        'comment': 'Matches all function parameters plus optional types'
        'begin': '(\\()'
        'end': '(\\))'
        'captures':
          '1':
            'name': 'meta.brace.round.ts'
        'patterns': [
          {
            'include': '#args'
          }
        ]
      }
      {
        'comment': 'Match function return type'
        'begin': '(?<=\\))\\s*:\\s*'
        'end': '(?!\\G)'
        'patterns': [
          {
            'include': '#type'
          }
        ]
      }
      # TODO find better name
      {
        'begin': '^\\s*(\\w+)(\\??)\\s*:\\s*'
        'beginCaptures':
          '1':
            'name': 'entity.name.variable.ts'
          '2':
            'name': 'keyword.operator.js'
        'end': '(?!\\G)'
        'patterns': [
          {
            'include': '#type'
          }
        ]
      }
      {
        'begin': '{'
        'end': '}'
        'patterns': [
          'include': '$self'
        ]
      }
      {
        'include': '#comments'
      }
    ]
  }
  {
    'comment': 'Prevent built-in types from being highlighted if accessed as property'
    'match': '(\\.)(?:Anchor|Applet|Area|Array|Boolean|Button|Checkbox|Date|document|event|FileUpload|Form|Frame|Function|Hidden|History|Image|JavaArray|JavaClass|JavaObject|JavaPackage|java|Layer|Link|Location|Math|MimeType|Number|navigator|netscape|Object|Option|Packages|Password|Plugin|Radio|RegExp|Reset|Select|String|Style|Submit|screen|sun|Text|Textarea|window|XMLHttpRequest)'
    'captures':
      '1':
        'name': 'meta.delimiter.method.period.js'
  }
  {
      'comment': 'Match export, declare and constructor'
      'match': '\\b(?:export|declare|constructor)\\b'
      'name': 'keyword.other.ts'
  }
  # REVIEW move this to other classes?
  {
    'comment': 'Match stuff like: as'
    'match': '\\b(?:as|AS)\\b'
    'name': 'keyword.operator.ts'
  }
  {
    'comment': 'Match stuff like: super(argument, list)'
    'match': '(super)\\)'
    'name': 'keyword.other.ts'
    'captures':
      '1':
        'name': 'variable.type.ts'
  }
  {
    'comment': 'Match type SomeType = OtherType'
    'begin': '(type)\\s+[\\w$]+\\s*=\\s*'
    'beginCaptures':
      '1':
        'name': 'storage.modifier.ts'
    'end': '(?!\\G)'
    'patterns': [
      {
        'include': '#type'
      }
    ]
  }
  {
    'comment': 'Match types in template instantiation'
    'begin': '(?<=\\w)<(?=([^&*/+-](?!\\|\\|))*>\\()'
    'end': '>'
    'patterns': [
      {
        'include': '#type'
      }
      {
        'include': '#comma'
      }
    ]
  }
  # TODO What does this do
  {
    'comment': 'Match stuff like: function() {...}'
    'match': '(?<function)\\s+([a-zA-Z_?.$][\\w?.$]*)\\(.*?)\\s*\\{'
    'name': 'meta.function.ts'
    'captures':
      '1':
        'name': 'entity.name.function.ts'
  }
  {
      'comment': 'Match full triple slash reference comments'
      'match': '(\\/\\/\\/\\s*<reference\\s*path\\s*=)(.*)(\\/>)'
      'captures':
        '1':
          'name':'keyword.other.ts'
        '2':
          'name':'reference.path.string'
        '3':
          'name':'keyword.other.ts'
  }
  {
      'comment': 'Match <amd-dependency'
      'match': '(\\/\\/\\/\\s*<amd-dependency\\s*path\\s*=)(.*)(\\/>)'
      'captures':
        '1':
          'name':'keyword.other.ts'
        '2':
          'name':'amd.path.string'
        '3':
          'name':'keyword.other.ts'
  }
  {
      'comment': 'Match <amd-module'
      'match': '(\\/\\/\\/\\s*<amd-module\\s*name\\s*=)(.*)(\\/>)'
      'captures':
        '1':
          'name':'keyword.other.ts'
        '2':
          'name':'amd.path.string'
        '3':
          'name':'keyword.other.ts'
  }
  {
      'comment': 'Match import = require'
      'match': '(import)\\s*(\\w*)\\s*=\\s*(require)\\s*\\((.*)\\)'
      'captures':
        '1':
           'name':'keyword.other.ts'
        '2':
          'name':'variable.type.ts'
        '3':
           'name':'keyword.other.ts'
        '4':
          'name':'require.path.string'
  }
  {
      'comment': 'Match ES6 "import from" syntax'
      'match': '(import).*(from)\\s*(.*[\'"])'
      'captures':
        '1':
           'name':'keyword.other.ts'
        '2':
           'name':'keyword.other.ts'
        '3':
          'name':'es6import.path.string'
  }
  {
    'include': 'source.js'
  }

  # TRANSFORMS
  {
      'comment': 'Embedded Syntaxes support'
      'begin': '(transform):(null){'
      'beginCaptures':
        '1':
          'name': 'keyword.other.ts'
        '2':
          'name': 'meta.support.constant.ts'
      'end': '}(transform):(null)'
      'endCaptures':
          '1':
            'name': 'keyword.other.ts'
          '2':
            'name': 'meta.support.constant.ts'
      'patterns': [
        {
          'include': 'source.ts'
        }
      ]
  }
  {
      'comment': 'Embedded Syntax for JSX'
      'begin': '(transform):(jsx){'
      'beginCaptures':
        '1':
          'name': 'keyword.other.ts'
        '2':
          'name': 'meta.support.constant.ts'
      'end': '}(transform):(jsx)'
      'endCaptures':
          '1':
            'name': 'keyword.other.ts'
          '2':
            'name': 'meta.support.constant.ts'
      'patterns': [
        {
          'include': 'text.html.basic'
        }
      ]
  }
]

'repository':
  'type':
    'begin': '(?=)'
    'end': '(?!\\G)'
    'patterns': [
      {
        'include': '#keytype'
      }
      {
        'include': '#typenontemplate'
      }
      {
        'include': '#typetemplate'
      }
      {
        'include': '#functiontype'
      }
      {
        'include': '#objecttype'
      }
      {
        'match': '\\|'
        'captures':
          '0':
            'name': 'keyword.operator.union.ts'
      }
      # IDEA Add all JS native objects with own syntax coloring?
    ]

  'typenontemplate':
    'comment': 'Matches a simple type without template specification'
    'match': '([_a-zA-Z\\$][\\w\\$]*)\\b((?:\\[\\])*)(?!<)'
    'captures':
      '1':
        'name': 'entity.storage.type.ts'

  'typetemplate':
    'begin': '([_a-zA-Z\\$][\\w\\$]*)<'
    'beginCaptures':
      '1':
        'name': 'entity.storage.type.template.ts'
    'end': '>((?:\\[\\])*)'
    'patterns': [
      {
        'include': '#type'
      }
      {
        'include': '#comma'
      }
    ]

  'keytype':
    'comment': 'Match key types.'
    'match': '(number|string|boolean|any)((?:\\[\\])*)'
    'captures':
      '1':
        'name': 'storage.type.variable.ts'
      '2':
        'name': 'storage.type.array.ts'
      # TODO find better name

  'functiontype':
    'patterns': [
      {
        'begin': '\\((?=\\()'
        'end': '(?<!\\))(?!\\G)\\)(\\[\\])+'
        'patterns': [
          {
            'include': '#completefunctiontype'
          }
        ]
        'name': 'functionarray'
      }
      {
        'include': '#completefunctiontype'
      }
    ]

  'completefunctiontype':
    'begin': '(?=\\()'
    'end': '(?<!\\))(?!\\G)'
    'patterns': [
      {
        'include': '#functionargumentstype'
      }
      {
        'begin': '(?<=\\))\\s*(=>)\\s*'
        'beginCaptures':
          '1':
            'name': 'meta.function.arrow.js'
        'end': '(?!\\G)'
        'patterns': [
          {
            'include': '#type'
          }
        ]
      }
    ]

  'functionargumentstype':
    'comment': 'Matches the types for functions.'
    'begin': '\\('
    'end': '\\)'
    'patterns': [
      {
        'include': '#typedvariable'
      }
    ]

  # REVIEW May need classes
  'objecttype':
    'comment': 'Matches anonymous object types.'
    'begin': '{'
    'end': '}(\\[\\])?'
    'patterns': [
      {
        'include': '#typedvariable'
      }
      {
        'match': ';'
        'name': 'meta.delimiter.semicolon.js'
      }
    ]

  'typedvariable':
    'begin': '[_a-zA-Z\\$][\\w\\$]*\\??\\s*:\\s*'
    'end': '(?!\\G)'
    'patterns': [
      {
        'include': '#type'
      }
    ]

  'args':
    'comment': 'Match the arguments in a function'
    'patterns': [
      {
        'match': '[_a-zA-Z\\$][\\w\\$]*(?=\\??\\s*[,\\)])'
        'name': 'variable.parameter.function.ts'
      }
      {
        'begin': '([_a-zA-Z\\$][\\w\\$]*)\\??\\s*:\\s*'
        'beginCaptures':
          '1':
            'name': 'variable.parameter.function.ts'
        'end': '(?=\\s*[,\\)])'
        'patterns': [
          {
            'include': '#type'
          }
        ]
      }
    ]

  # Taken from JS grammar (https://github.com/atom/language-javascript/blob/897e999910fb001780286778a20b7e5c02eb59dd/grammars/javascript.cson#L631-L661)
  'docblock':
    'patterns': [
      {
        'match': '(?<!\\w)@(abstract|access|alias|augments|author|async|attribute|arg|argument|beta|borrows|bubbes|callback|class|classdesc|config|const|constant|constructs|constructor|copyright|chainable|default|defaultvalue|deprecated|desc|description|enum|emits|event|example|exports|external|extends|extension|extensionfor|extension_for|for|file|fileoverview|fires|final|function|global|host|ignore|implements|inheritdoc|inner|instance|interface|kind|lends|license|listens|main|member|memberof|method|mixex|mixin|module|name|namespace|override|overview|param|private|prop|property|protected|readonly|readOnly|requires|required|return|returns|see|since|static|summary|submodule|this|throws|todo|tutorial|type|typedef|var|variation|version|virtual|uses|writeOnce)\\b'
        'name': 'storage.type.class.jsdoc'
      }
    ]

  'comments':
    'patterns': [
      {
        'begin': '/\\*\\*(?!/)'
        'captures':
          '0':
            'name': 'punctuation.definition.comment.js'
        'patterns': [
          {
            'include': '#docblock'
          }
        ]
        'end': '\\*/'
        'name': 'comment.block.documentation.js'
      }
      {
        'begin': '/\\*'
        'captures':
          '0':
            'name': 'punctuation.definition.comment.js'
        'end': '\\*/'
        'name': 'comment.block.js'
      }
    ]

    'comma':
        'match': ','
        'name': 'meta.delimiter.object.comma.js'
