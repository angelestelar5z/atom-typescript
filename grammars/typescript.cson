'scopeName': 'source.ts'
'comment': 'TypeScript Syntax: version 1.0'
'fileTypes': [
  'ts'
  'str'
  'tst'
]
'name': 'TypeScript'

'patterns': [
  {
    'comment': 'Match stuff like: namespace name {...}'
    'match': '\\b(module|namespace)\\s+(\\s*[\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}]*)\\s*'
    'captures':
      '1':
        'name': 'keyword.other.ts'
      '2':
        'name': 'entity.name.namespace.ts'
  }
  {
    'comment': 'Match types in variable definitions.'
    'begin': '(var|const|let)\\s+'
    'beginCaptures':
      '1':
        'name': 'storage.modifier.js'
    'end': '(;)|(?<!,)$'
    'endCaptures':
      '1':
        'name': 'punctuation.terminator.statement.js'
    'patterns': [
      {
        'begin': '(?<=^|,|\\G)'
        'end': '(,)|(?=;)'
        'endCaptures':
          '1':
            'include': '#comma'
        'patterns': [
          {
            'include': '#typedvariable'
          }
          {
            'begin': '\\s*(=)\\s*'
            'end': '(?=[,;])'
            'beginCaptures':
              '1':
                'name': 'keyword.operator.js'
            'patterns': [
              {
                'include': '$self'
              }
            ]
          }
          {
            'include': '#comments'
          }
        ]
      }
    ]
  }
  {
    'begin': '(interface)|(class)'
    'beginCaptures':
      '1':
        'name': 'storage.type.interface.js'
      '2':
        'name': 'storage.type.class.js'
    'end': '}'
    'patterns': [
      {
        # Grammar rule originally taken from JavaScript grammar, but heavily modified (https://github.com/atom/language-javascript/blob/517019cdc8e9114b13c2edcebf4ec49cf27e7a64/grammars/javascript.cson#L263-L279)
        'begin': '\\G\\s+([\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}]*(?:\\.(?:[\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}]*)?)?(?:<[\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}]*(?:\\s*,\\s*[\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}]*)*>)?)?(?:\\s+(extends)\\s)?'
        'beginCaptures':
          '1':
            'patterns': [
              {
                'match': '[\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}]*'
                'name': 'meta.class.ts'
              }
              {
                'match': ','
                'name': 'meta.delimiter.object.comma.js'
              }
            ]
          '2':
            'name': 'storage.modifier.ts'
        'end': '(?<!extends\\s)\\s*{'
        'patterns': [
          {
            'include': '#typeinheritedfrom'
          }
          {
            'include': '#comments'
          }
          {
            'include': '#comma'
          }
        ]
      }
      {
        'comment': 'Matches class method names and styles as function, even if marked private, or getters/setters'
        'begin': '(?:(private|puclic)\\s+)?((?:[\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}]*)?)<'
        'beginCaptures':
          '1':
            'name': 'storage.modifier.js'
          '2':
            'name': 'entity.name.function.js'
        'end': '>(?=\\()'
        'patterns': [
          {
            'include': '#typeextend'
          }
          {
            'include': '#type'
          }
          {
            'include': '#comma'
          }
          {
            'include': '#comments'
          }
        ]
      }
      {
        'match': '(?:(private|public)\\s+)?(?:(get|set)\\s+)?([\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}]*)(?=\\()'
        'captures':
          '1':
            'name': 'storage.modifier.js'
          '2':
            'name': 'storage.modifier.ts'
          '3':
            'name': 'entity.name.function.js'
      }
      {
        'include': '#functionargumentstype'
      }
      {
        'comment': 'Match function return type'
        'begin': '(?<=\\))\\s*:\\s*'
        'end': '(?!\\G)'
        'patterns': [
          {
            'include': '#type'
          }
          {
            'include': '#comments'
          }
        ]
      }
      {
        'begin': '([\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}]*)(\\??)\\s*:\\s*'
        'beginCaptures':
          '1':
            'name': 'entity.name.variable.ts'
          '2':
            'name': 'keyword.operator.js'
        'end': '(?!\\G)'
        'patterns': [
          {
            'include': '#type'
          }
          {
            'include': '#comments'
          }
        ]
      }
      {
        'match': '([\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}]*)(\\??)'
        'captures':
          '1':
            'name': 'entity.name.variable.ts'
          '2':
            'name': 'keyword.operator.js'
      }
      {
        'begin': '\\s*(=)\\s*'
        'beginCaptures':
          '1':
            'name': 'keyword.operator.js'
        'end': '(;)|$'
        'endCaptures':
          '1':
            'name': 'meta.delimiter.semicolon.js'
        'patterns': [
          'include': '$self'
        ]
      }
      {
        'include': '#curlybracerecursion'
      }
      {
        'comment': 'Match keywords static'
        'match': 'static'
        'captures':
          '0':
            'name': 'storage.modifier.js'
      }
      {
        'match': ';'
        'name': 'meta.delimiter.semicolon.js'
      }
      {
        'include': '#comments'
      }
    ]
  }
  {
    'begin': '([\\p{L}\\p{Nl}$_.][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}.]*)\\.(prototype)\\.([\\p{L}\\p{Nl}$_.][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}.]*)\\s*(=)\\s*(?=(?:(?:async\\s+)?function)|(?:\\((?:[^&|*/+\\-\\)]|\\)\\]|\\/\\*\\*?(?:[^*]*?\\*)*\\/|\\|(?:[^&|*/+\\-\\)]|\\)\\]|\\/\\*\\*?(?:[^*]*?\\*)*\\/))*\\)(?:\\:\\s*(?:[^:&|*/+\\-\\)]|\\)\\]|\\/\\*\\*?(?:[^*]*?\\*)*\\/|\\|(?:[^:&|*/+\\-\\)]|\\)\\]|\\/\\*\\*?(?:[^*]*?\\*)*\\/))+)?\\s*=>\\s*{))'
    'beginCaptures':
      '1':
        'name': 'support.class.js'
      '2':
        'name': 'support.constant.js'
      '3':
        'name': 'entity.name.function.js'
      '4':
        'name': 'keyword.operator.js'
    'comment': 'match stuff like: Sound.prototype.play = function() { … }'
    'end': '(?!\\G)'
    'name': 'meta.function.prototype.js'
    'patterns': [
      {
        'include': '#function'
      }
      {
        'include': '#comments'
      }
    ]
  }
  {
    'begin': '([\\p{L}\\p{Nl}$_.][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}.]*)\\.([\\p{L}\\p{Nl}$_.][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}.]*)\\s*(=)\\s*(?=(?:(?:async\\s+)?function)|(?:\\((?:[^&|*/+\\-\\)]|\\)\\]|\\/\\*\\*?(?:[^*]*?\\*)*\\/|\\|(?:[^&|*/+\\-\\)]|\\)\\]|\\/\\*\\*?(?:[^*]*?\\*)*\\/))*\\)(?:\\:\\s*(?:[^:&|*/+\\-\\)]|\\)\\]|\\/\\*\\*?(?:[^*]*?\\*)*\\/|\\|(?:[^:&|*/+\\-\\)]|\\)\\]|\\/\\*\\*?(?:[^*]*?\\*)*\\/))+)?\\s*=>\\s*{))'
    'beginCaptures':
      '1':
        'name': 'support.class.js'
      '2':
        'name': 'entity.name.function.js'
      '3':
        'name': 'keyword.operator.js'
    'comment': 'match stuff like: Sound.play = function() { … }'
    'end': '(?!\\G)'
    'name': 'meta.function.js'
    'patterns': [
      {
        'include': '#function'
      }
      {
        'include': '#comments'
      }
    ]
  }
  {
    'begin': '([\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}]*)\\s*(=)\\s*(?=(?:(?:async\\s+)?function)|(?:\\((?:[^&|*/+\\-\\)]|\\)\\]|\\/\\*\\*?(?:[^*]*?\\*)*\\/|\\|(?:[^&|*/+\\-\\)]|\\)\\]|\\/\\*\\*?(?:[^*]*?\\*)*\\/))*\\)(?:\\:\\s*(?:[^:&|*/+\\-\\)]|\\)\\]|\\/\\*\\*?(?:[^*]*?\\*)*\\/|\\|(?:[^:&|*/+\\-\\)]|\\)\\]|\\/\\*\\*?(?:[^*]*?\\*)*\\/))+)?\\s*=>\\s*{))'
    'beginCaptures':
      '1':
        'name': 'entity.name.function.js'
      '2':
        'name': 'keyword.operator.js'
    'comment': 'match stuff like: play = function() { … }'
    'end': '(?!\\G)'
    'name': 'meta.function.js'
    'patterns': [
      {
        'include': '#function'
      }
      {
        'include': '#comments'
      }
    ]
  }
  {
    'begin': '\\b([\\p{L}\\p{Nl}$_.][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}.]*)\\s*(:)\\s*(?=(?:(?:async\\s+)?function)|(?:\\((?:[^&|*/+\\-\\)]|\\)\\]|\\/\\*\\*?(?:[^*]*?\\*)*\\/|\\|(?:[^&|*/+\\-\\)]|\\)\\]|\\/\\*\\*?(?:[^*]*?\\*)*\\/))*\\)(?:\\:\\s*(?:[^:&|*/+\\-\\)]|\\)\\]|\\/\\*\\*?(?:[^*]*?\\*)*\\/|\\|(?:[^:&|*/+\\-\\)]|\\)\\]|\\/\\*\\*?(?:[^*]*?\\*)*\\/))+)?\\s*=>\\s*{))'
    'beginCaptures':
      '1':
        'name': 'entity.name.function.js'
      '2':
        'name': 'keyword.operator.js'
    'comment': 'match stuff like: foobar: function() { … }'
    'end': '(?!\\G)'
    'name': 'meta.function.json.js'
    'patterns': [
      {
        'include': '#function'
      }
      {
        'include': '#comments'
      }
    ]
  }
  {
    'begin': '(?:((\')(.*?)(\'))|((")(.*?)(")))\\s*(:)\\s*(?=(?:(?:async\\s+)?function)|(?:\\((?:[^&|*/+\\-\\)]|\\)\\]|\\/\\*\\*?(?:[^*]*?\\*)*\\/|\\|(?:[^&|*/+\\-\\)]|\\)\\]|\\/\\*\\*?(?:[^*]*?\\*)*\\/))*\\)(?:\\:\\s*(?:[^:&|*/+\\-\\)]|\\)\\]|\\/\\*\\*?(?:[^*]*?\\*)*\\/|\\|(?:[^:&|*/+\\-\\)]|\\)\\]|\\/\\*\\*?(?:[^*]*?\\*)*\\/))+)?\\s*=>\\s*{))'
    'beginCaptures':
      '1':
        'name': 'string.quoted.single.js'
      '2':
        'name': 'punctuation.definition.string.begin.js'
      '3':
        'name': 'entity.name.function.js'
      '4':
        'name': 'punctuation.definition.string.end.js'
      '5':
        'name': 'string.quoted.double.js'
      '6':
        'name': 'punctuation.definition.string.begin.js'
      '7':
        'name': 'entity.name.function.js'
      '8':
        'name': 'punctuation.definition.string.end.js'
      '9':
        'name': 'keyword.operator.js'
    'comment': 'Attempt to match "foo": function'
    'end': '(?!\\G)'
    'name': 'meta.function.json.js'
    'patterns': [
      {
        'include': '#function'
      }
      {
        'include': '#comments'
      }
    ]
  }
  {
    'include': '#function'
  }
  {
    'begin': '(?<=[\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}\\)\\]])(\\()'
    'beginCaptures':
      '1':
        'name': 'punctuation.definition.parameters.begin.js'
    'end': '\\)'
    'endCaptures':
      '0':
        'name': 'punctuation.definition.parameters.end.js'
    'patterns': [
      {
        'begin': '(?=)'
        'end': '(,)\\s*|(?=\\))'
        'endCaptures':
          '1':
            'include': '#comma'
        'contentName': 'variable.function.parameter.ts'
        'patterns': [
          {
            'include': '$self'
          }
        ]
      }
      {
        'include': '#comments'
      }
    ]
  }
  {
    'comment': 'Prevent built-in types from being highlighted if accessed as property'
    'match': '(\\.)(?:Anchor|Applet|Area|Array|Boolean|Button|Checkbox|Date|document|event|FileUpload|Form|Frame|Function|Hidden|History|Image|JavaArray|JavaClass|JavaObject|JavaPackage|java|Layer|Link|Location|Math|MimeType|Number|navigator|netscape|Object|Option|Packages|Password|Plugin|Radio|RegExp|Reset|Select|String|Style|Submit|screen|sun|Text|Textarea|window|XMLHttpRequest)'
    'captures':
      '1':
        'name': 'meta.delimiter.method.period.js'
  }
  {
      'comment': 'Match export, declare and constructor'
      'match': '\\b(?:export|declare|constructor)\\b'
      'name': 'keyword.other.ts'
  }
  {
    'comment': 'Match stuff like: as'
    'match': '\\b(?:as|AS)\\b'
    'name': 'keyword.operator.ts'
  }
  {
    'comment': 'Match stuff like: super(argument, list)'
    'match': '(super)\\)'
    'name': 'keyword.other.ts'
    'captures':
      '1':
        'name': 'variable.type.ts'
  }
  {
    'comment': 'Match type SomeType = OtherType'
    'begin': '(type)\\s+[\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}]*\\s*=\\s*'
    'beginCaptures':
      '1':
        'name': 'storage.modifier.ts'
    'end': '(?!\\G)'
    'patterns': [
      {
        'include': '#type'
      }
      {
        'include': '#comments'
      }
    ]
  }
  {
    'comment': 'Match types in template instantiation'
    'begin': '(?<=[\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}])<(?=(?:[^:\\/*&|+-]|\\/\\*\\*?(?:[^*]*?\\*)*\\/|\\|(?:[^:\\/*&|+-]|\\/\\*\\*?(?:[^*]*?\\*)*\\/))+>\\()'
    'end': '>'
    'patterns': [
      {
        'include': '#type'
      }
      {
        'include': '#comma'
      }
      {
        'include': '#comments'
      }
    ]
  }
  {
      'comment': 'Match full triple slash reference comments'
      'match': '(\\/\\/\\/\\s*<reference\\s*path\\s*=)(.*)(\\/>)'
      'captures':
        '1':
          'name':'keyword.other.ts'
        '2':
          'name':'reference.path.string'
        '3':
          'name':'keyword.other.ts'
  }
  {
      'comment': 'Match <amd-dependency'
      'match': '(\\/\\/\\/\\s*<amd-dependency\\s*path\\s*=)(.*)(\\/>)'
      'captures':
        '1':
          'name':'keyword.other.ts'
        '2':
          'name':'amd.path.string'
        '3':
          'name':'keyword.other.ts'
  }
  {
      'comment': 'Match <amd-module'
      'match': '(\\/\\/\\/\\s*<amd-module\\s*name\\s*=)(.*)(\\/>)'
      'captures':
        '1':
          'name':'keyword.other.ts'
        '2':
          'name':'amd.path.string'
        '3':
          'name':'keyword.other.ts'
  }
  {
      'comment': 'Match import = require'
      'match': '(import)\\s*([\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}]*)?\\s*=\\s*(require)\\s*\\((.*)\\)'
      'captures':
        '1':
           'name':'keyword.other.ts'
        '2':
          'name':'variable.type.ts'
        '3':
           'name':'keyword.other.ts'
        '4':
          'name':'require.path.string'
  }
  {
      'comment': 'Match ES6 "import from" syntax'
      'match': '(import).*(from)\\s*(.*[\'"])'
      'captures':
        '1':
           'name':'keyword.other.ts'
        '2':
           'name':'keyword.other.ts'
        '3':
          'name':'es6import.path.string'
  }
  {
    'include': '#curlybracerecursion'
  }
  {
    'comment': 'Match all [] pairs'
    'begin': '\\['
    'end': '\\]'
    'captures':
      '0':
        'name': 'meta.brace.square.js'
    'patterns': [
      {
        'include': '$self'
      }
    ]
  }
  {
    'comment': 'Match all () pairs'
    'begin': '\\('
    'end': '\\)'
    'captures':
      '0':
        'name': 'meta.brace.round.js'
    'patterns': [
      {
        'include': '$self'
      }
    ]
  }
  {
    'include': 'source.js'
  }

  # TRANSFORMS
  {
      'comment': 'Embedded Syntaxes support'
      'begin': '(transform):(null){'
      'beginCaptures':
        '1':
          'name': 'keyword.other.ts'
        '2':
          'name': 'meta.support.constant.ts'
      'end': '}(transform):(null)'
      'endCaptures':
          '1':
            'name': 'keyword.other.ts'
          '2':
            'name': 'meta.support.constant.ts'
      'patterns': [
        {
          'include': 'source.ts'
        }
      ]
  }
  {
      'comment': 'Embedded Syntax for JSX'
      'begin': '(transform):(jsx){'
      'beginCaptures':
        '1':
          'name': 'keyword.other.ts'
        '2':
          'name': 'meta.support.constant.ts'
      'end': '}(transform):(jsx)'
      'endCaptures':
          '1':
            'name': 'keyword.other.ts'
          '2':
            'name': 'meta.support.constant.ts'
      'patterns': [
        {
          'include': 'text.html.basic'
        }
      ]
  }
]

'repository':
  'curlybracerecursion':
    'comment': 'Match all {} pairs'
    'begin': '{'
    'end': '}'
    'captures':
      '0':
        'name': 'meta.brace.curly.js'
    'patterns': [
      {
        'include': '$self'
      }
    ]

  'type':
    'begin': '(?=)'
    'end': '(?<!\\*\\/)(?<!\\|)(?!\\G)(?!\\|)'
    'patterns': [
      {
        'include': '#keytype'
      }
      {
        'include': '#typenontemplate'
      }
      {
        'include': '#typetemplate'
      }
      {
        'include': '#functiontype'
      }
      {
        'include': '#objecttype'
      }
      {
        'match': '\\|'
        'captures':
          '0':
            'name': 'keyword.operator.union.ts'
      }
      {
        'include': '#comments'
      }
    ]

  'typeinheritedfrom':
    'begin': '(?=)'
    'end': '(?<!\\*\\/)(?<!\\|)(?!\\G)(?!\\|)'
    'patterns': [
      {
        'include': '#keytype'
      }
      {
        'include': '#functiontype'
      }
      {
        'include': '#objecttype'
      }
      {
        'include': '#typetemplateinheritedfrom'
      }
      {
        'include': '#typenontemplateinheritedfrom'
      }
      {
        'match': '\\|'
        'captures':
          '0':
            'name': 'keyword.operator.union.ts'
      }
      {
        'include': '#comments'
      }
    ]

  'typenontemplate':
    'comment': 'Matches a simple type without template specification'
    'match': '([\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}]*)\\b((?:\\[\\])*)(?!<)'
    'captures':
      '1':
        'name': 'support.class.ts'

  'typetemplate':
    'begin': '([\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}]*)<'
    'beginCaptures':
      '1':
        'name': 'support.class.template.ts'
    'end': '>((?:\\[\\])*)'
    'patterns': [
      {
        'include': '#type'
      }
      {
        'include': '#comma'
      }
      {
        'include': '#comments'
      }
    ]

  'typenontemplateinheritedfrom':
    'comment': 'Matches a simple type without template specification'
    'match': '([\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}]*)\\b((?:\\[\\])*)(?!<)'
    'captures':
      '1':
        'name': 'support.class.inherited-from.ts'

  'typetemplateinheritedfrom':
    'begin': '([\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}]*)<'
    'beginCaptures':
      '1':
        'name': 'support.class.template.inherited-from.ts'
    'end': '>((?:\\[\\])*)'
    'patterns': [
      {
        'include': '#type'
      }
      {
        'include': '#comma'
      }
      {
        'include': '#comments'
      }
    ]

  'keytype':
    'comment': 'Match key types.'
    'match': '(number|string|boolean|any|void)(?:\\[\\])*'
    'captures':
      '1':
        'name': 'storage.type.variable.ts'

  'functiontype':
    'patterns': [
      {
        'begin': '\\((?=\\()'
        'end': '(?<!\\))(?!\\G)\\)(\\[\\])*'
        'patterns': [
          {
            'include': '#completefunctiontype'
          }
        ]
        'name': 'functionarray'
      }
      {
        'include': '#completefunctiontype'
      }
      {
        'include': '#comments'
      }
    ]

  'completefunctiontype':
    'begin': '(?=\\()'
    'end': '(?<!\\))(?!\\G)'
    'patterns': [
      {
        'include': '#functionargumentstype'
      }
      {
        'begin': '(?<=\\))\\s*(=>)\\s*'
        'beginCaptures':
          '1':
            'name': 'storage.type.arrow.js'
        'end': '(?!\\G)'
        'patterns': [
          {
            'include': '#type'
          }
          {
            'include': '#comments'
          }
        ]
      }
      {
        'include': '#comments'
      }
    ]

  'functionargumentstype':
    'comment': 'Matches the types for functions.'
    'begin': '\\('
    'beginCaptures':
      '0':
        'name': 'punctuation.definition.parameters.begin.js'
    'end': '\\)'
    'endCaptures':
      '0':
        'name': 'punctuation.definition.parameters.end.js'
    'patterns': [
      {
        'include': '#args'
      }
      {
        'include': '#comments'
      }
    ]

  'objecttype':
    'comment': 'Matches anonymous object types.'
    'begin': '{'
    'beginCaptures':
      '0':
        'name': 'meta.brace.curly.js'
    'end': '(})(\\[\\])?'
    'endCaptures':
      '1':
        'name': 'meta.brace.curly.js'
    'patterns': [
      {
        'include': '#typedvariable'
      }
      {
        'match': ';'
        'name': 'meta.delimiter.semicolon.js'
      }
      {
        'include': '#comments'
      }
    ]

  'typedvariable':
    'begin': '[\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}]*\\??\\s*:\\s*'
    'end': '(?!\\G)'
    'patterns': [
      {
        'include': '#type'
      }
      {
        'include': '#comments'
      }
    ]

  'args':
    'comment': 'Match the arguments in a function'
    'patterns': [
      {
        'match': '[\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}]*(?=\\??\\s*[,\\)])'
        'name': 'variable.parameter.function.ts'
      }
      {
        'begin': '([\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}]*)\\??\\s*:\\s*'
        'beginCaptures':
          '1':
            'name': 'variable.parameter.function.ts'
        'end': '(?=\\s*[,\\)])'
        'patterns': [
          {
            'include': '#type'
          }
          {
            'include': '#comments'
          }
        ]
      }
      {
        'include': '#comma'
      }
      {
        'include': '#comments'
      }
    ]

  'function':
    'patterns': [
      {
        'include': '#oldstylefunction'
      }
      {
        'include': '#newstylefunction'
      }
    ]

  'newstylefunction':
    'begin': '(?<![\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}\\)\\]].)(?=\\([^\\(].+=>)(?=(?:[^&|*/+\\-\\)]|\\)\\]|\\/\\*\\*?(?:[^*]*?\\*)*\\/|\\|(?:[^&|*/+\\-\\)]|\\)\\]|\\/\\*\\*?(?:[^*]*?\\*)*\\/))*\\)(?:\\:\\s*(?:[^:&|*/+\\-\\)]|\\)\\]|\\/\\*\\*?(?:[^*]*?\\*)*\\/|\\|(?:[^:&|*/+\\-\\)]|\\)\\]|\\/\\*\\*?(?:[^*]*?\\*)*\\/))+)?\\s*=>\\s*{)'
    'end': '(?!\\:)\\s*(=>)'
    'endCaptures':
      '1':
        'name': 'storage.type.arrow.js'
    'patterns': [
      {
        'include': '#functionargumentstype'
      }
      {
        'begin': '\\:\\s*'
        'end': '(?!\\G)'
        'patterns': [
          {
            'include': '#type'
          }
          {
            'include': '#comments'
          }
        ]
      }
      {
        'include': '#comments'
      }
    ]

  'oldstylefunction':
    'begin': '(?=(?:(async)(?:\\s+))?(function))'
    'end': '(?!\\G)(?!:)'
    'name': 'meta.function.js'
    'patterns': [
      {
        'begin': '(?:(async)(?:\\s+))?(function)(?:\\s+([\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}]*))?(\\*?)\\s*(\\*?)(?=\\()'
        'beginCaptures':
          '1':
            'name': 'storage.modifier.js'
          '2':
            'name': 'storage.type.function.js'
          '3':
            'name': 'entity.name.function.js'
          '4':
            'name': 'storage.type.function.js'
          '5':
            'name': 'storage.type.function.js'
        'end': '(?<=\\))'
        'patterns': [
          {
            'include': '#functionargumentstype'
          }
          {
            'include': '#comments'
          }
        ]
      }
      {
        'begin': '(?:(async)(?:\\s+))?(function)(?:\\s+([\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\x{200C}\\x{200D}]*))?(?=<)'
        'beginCaptures':
          '1':
            'name': 'storage.modifier.js'
          '2':
            'name': 'storage.type.function.js'
          '3':
            'name': 'entity.name.function.js'
        'end': '(?<=\\))'
        'patterns': [
          {
            'begin': '(?<=\\G)<'
            'end': '>(?:(\\*)\\s*|\\s*(\\*)|\\s*)(?=\\()'
            'endCaptures':
              '1':
                'name': 'storage.type.function.js'
              '2':
                'name': 'storage.type.function.js'
            'patterns': [
              {
                'include': '#typeextend'
              }
              {
                'include': '#type'
              }
              {
                'include': '#comma'
              }
              {
                'include': '#comments'
              }
            ]
          }
          {
            'include': '#functionargumentstype'
          }
          {
            'include': '#comments'
          }
        ]
      }
      {
        'begin': '(?<=\\)):\\s*'
        'end': '(?!\\G)'
        'patterns': [
          {
            'include': '#type'
          }
          {
            'include': '#comments'
          }
        ]
      }
      {
        'include': '#comments'
      }
    ]

  'typeextend':
    'begin': '(extends)\\s+'
    'beginCaptures':
      '1':
        'name': 'storage.type.modifier.ts'
    'end': '(?!\\G)'
    'patterns': [
      {
        'include': '#typeinheritedfrom'
      }
    ]

  # Taken from JS grammar (https://github.com/atom/language-javascript/blob/897e999910fb001780286778a20b7e5c02eb59dd/grammars/javascript.cson#L631-L661)
  'docblock':
    'patterns': [
      {
        'match': '(?<!\\w)@(abstract|access|alias|augments|author|async|attribute|arg|argument|beta|borrows|bubbes|callback|class|classdesc|config|const|constant|constructs|constructor|copyright|chainable|default|defaultvalue|deprecated|desc|description|enum|emits|event|example|exports|external|extends|extension|extensionfor|extension_for|for|file|fileoverview|fires|final|function|global|host|ignore|implements|inheritdoc|inner|instance|interface|kind|lends|license|listens|main|member|memberof|method|mixex|mixin|module|name|namespace|override|overview|param|private|prop|property|protected|readonly|readOnly|requires|required|return|returns|see|since|static|summary|submodule|this|throws|todo|tutorial|type|typedef|var|variation|version|virtual|uses|writeOnce)\\b'
        'name': 'storage.type.class.jsdoc'
      }
    ]

  'comments':
    'patterns': [
      {
        'begin': '/\\*\\*(?!/)'
        'captures':
          '0':
            'name': 'punctuation.definition.comment.js'
        'patterns': [
          {
            'include': '#docblock'
          }
        ]
        'end': '\\*/'
        'name': 'comment.block.documentation.js'
      }
      {
        'begin': '/\\*'
        'captures':
          '0':
            'name': 'punctuation.definition.comment.js'
        'end': '\\*/'
        'name': 'comment.block.js'
      }
    ]

  'comma':
      'match': ','
      'name': 'meta.delimiter.object.comma.js'
