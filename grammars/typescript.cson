'scopeName': 'source.ts'
'comment': 'TypeScript Syntax: version 1.0'
'fileTypes': [
  'ts'
  'str'
  'tst'
]
'name': 'TypeScript'

'patterns': [
  {
    'comment': 'Match stuff like: namespace name {...}'
    'match': '\\b(module|namespace)\\s+(\\s*[a-zA-Z0-9_?.$][\\w?.$]*)\\s*'
    'name': 'meta.function.ts'
    'captures':
      '1':
        'name': 'keyword.other.ts'
      '2':
        'name': 'entity.name.module.ts'
  }
  {
    'comment': 'Match this.'
    'match': '\\b(this)\\b'
    'captures':
      '1':
        'name': 'storage.type.variable.ts'
  }
  # TODO Highlight types after extend
  {
    'match': '\\b(interface)(?:(?:\\s+(extends)\\s+(\\w+(?:\\.\\w*)?))|(?:(?:\\s+(\\w+(?:\\.\\w*)?))(?:\\s+(extends)\\s+(\\w+(?:\\.\\w*)?))?))'
    'captures':
      '1':
        'name': 'storage.type.interface.ts'
      '2':
        'name': 'storage.modifier.ts'
      '3':
        'name': 'entity.name.type.ts'
      '4':
        'name': 'entity.name.type.ts'
      '5':
        'name': 'storage.modifier.ts'
      '6':
        'name': 'entity.name.type.ts'
    'name': 'meta.interface.ts'
  }
  {
      'comment': 'Match export, declare and constructor'
      'match': '\\b(?:export|declare|constructor)\\b'
      'name': 'keyword.other.ts'
  }
  {
      'comment': 'Match public and private'
      'match': '\\b(?:public|private)\\b'
      'name': 'keyword.type.modifier.ts'
  }
  # TODO move this to other classes?
  {
    'comment': 'Match stuff like: as'
    'match': '\\b(?:as|AS)\\b'
    'name': 'keyword.operator.ts'
  }
  {
    'comment': 'Match stuff like: super(argument, list)'
    'match': '(super)\\)'
    'name': 'keyword.other.ts'
    'captures':
      '1':
        'name': 'variable.type.ts'
  }
  # TODO match extend types and stuff here
  {
    'comment': 'Matches class method names and styles as function, even if marked private, or getters/setters'
    'match': '^\\s*(?:(private)\\s+)?(?:(get|set)?\\s+(\\w+)|(\\w+)<[^>]+>)(?=\\()'
    'captures':
      '1':
        'name': 'keyword.other.ts'
      '2':
        'name': 'storage.modifier.ts'
      '3':
        'name': 'entity.name.function.ts'
      '4':
        'name': 'entity.name.function.ts'
  }
  # TODO What does this do
  {
    'comment': 'Match stuff like: function() {...}'
    'match': '(?<function)\\s+([a-zA-Z_?.$][\\w?.$]*)\\(.*?)\\s*\\{'
    'name': 'meta.function.ts'
    'captures':
      '1':
        'name': 'entity.name.function.ts'
  }
  {
    'comment': 'Matches the types when typing params or variables, such as (param:type1, param2:type2):type3, and var x:string = ...'
    'begin': ':\\s*\\b'
    'end': '(?!\\G)'
    'patterns': [
      {
        'include': '#type'
      }
    ]
    'disabled': true
  }
  {
    'comment': "Matches all function parameters (but not the parameter's types)"
    'begin': '(\\()'
    'end': '(\\))'
    'captures':
      '1':
        'name': 'meta.brace.round.ts'
    'patterns': [
      {
        'include': '#args'
      }
    ]
  }
  {
      'comment': 'Match full triple slash reference comments'
      'match': '(\\/\\/\\/\\s*<reference\\s*path\\s*=)(.*)(\\/>)'
      'captures':
        '1':
          'name':'keyword.other.ts'
        '2':
          'name':'reference.path.string'
        '3':
          'name':'keyword.other.ts'
  }
  {
      'comment': 'Match <amd-dependency'
      'match': '(\\/\\/\\/\\s*<amd-dependency\\s*path\\s*=)(.*)(\\/>)'
      'captures':
        '1':
          'name':'keyword.other.ts'
        '2':
          'name':'amd.path.string'
        '3':
          'name':'keyword.other.ts'
  }
  {
      'comment': 'Match <amd-module'
      'match': '(\\/\\/\\/\\s*<amd-module\\s*name\\s*=)(.*)(\\/>)'
      'captures':
        '1':
          'name':'keyword.other.ts'
        '2':
          'name':'amd.path.string'
        '3':
          'name':'keyword.other.ts'
  }
  {
      'comment': 'Match import = require'
      'match': '(import)\\s*(\\w*)\\s*=\\s*(require)\\s*\\((.*)\\)'
      'captures':
        '1':
           'name':'keyword.other.ts'
        '2':
          'name':'variable.type.ts'
        '3':
           'name':'keyword.other.ts'
        '4':
          'name':'require.path.string'
  }
  {
      'comment': 'Match ES6 "import from" syntax'
      'match': '(import).*(from)\\s*(.*[\'"])'
      'captures':
        '1':
           'name':'keyword.other.ts'
        '2':
           'name':'keyword.other.ts'
        '3':
          'name':'es6import.path.string'
  }
  {
    'include': 'source.js'
  }

  # TRANSFORMS
  {
      'comment': 'Embedded Syntaxes support'
      'begin': '(transform):(null){'
      'beginCaptures':
        '1':
          'name': 'keyword.other.ts'
        '2':
          'name': 'meta.support.constant.ts'
      'end': '}(transform):(null)'
      'endCaptures':
          '1':
            'name': 'keyword.other.ts'
          '2':
            'name': 'meta.support.constant.ts'
      'patterns': [
        {
          'include': 'source.ts'
        }
      ]
  }
  {
      'comment': 'Embedded Syntax for JSX'
      'begin': '(transform):(jsx){'
      'beginCaptures':
        '1':
          'name': 'keyword.other.ts'
        '2':
          'name': 'meta.support.constant.ts'
      'end': '}(transform):(jsx)'
      'endCaptures':
          '1':
            'name': 'keyword.other.ts'
          '2':
            'name': 'meta.support.constant.ts'
      'patterns': [
        {
          'include': 'text.html.basic'
        }
      ]
  }
]

'repository':
  'type':
    'patterns': [
      {
          'include': '#keytype'
      }
      {
        'include': '#typenontemplate'
      }
      {
        'include': '#typetemplate'
      }
      {
        'include': '#functiontype'
      }
      {
        'include': '#objecttype'
      }
    ]
    #'name': 'meta.type.ts'
  'typenontemplate':
    'comment': 'Matches a simple type without template specification'
    'match': '[_a-zA-Z\\$][\\w\\$]*\\b(?!<)'
    'name': 'entity.storage.type.ts'

  'typetemplate':
    'begin': '([_a-zA-Z\\$][\\w\\$]*)<'
    'beginCaptures':
      '1':
        'name': 'entity.storage.type.template.ts'
    'end': '>'
    'patterns': [
      {
        'include': '#type'
      }
      {
        'match': ','
        'name': 'meta.delimiter.object.comma.js'
      }
    ]

  'keytype':
    'comment': 'Match key types.'
    'match': 'number|string|boolean|any'
    'name': 'storage.type.variable.ts'

  # TODO Fix this up (for more than one line).
  # TODO Does not work for function with arguments, match stops after first argument.
  'functiontype':
    'comment': 'Matches the types for functions.'
    'begin': '\\('
    'end': '\\b(?!=>)'
    'name': 'functiontype.ts'
    'patterns': [
      {
        'begin': '\\)\\s*=>\\s*'
        'end': '(?!\\G)'
        'patterns': [
          {
            'include': '#type'
          }
        ]
      }
      {
        'include': '#typedvariable'
      }
    ]

  # TODO May need classes
  'objecttype':
    'comment': 'Matches anonymous object types.'
    'begin': '{'
    'end': '}'
    'patterns': [
      {
        'include': '#typedvariable'
      }
    ]

  'typedvariable':
    'begin': '[_a-zA-Z\\$][\\w\\$]*\\??\\s*:\\s*'
    'end': '(?=\\s*[,\\)])'
    'patterns': [
      {
        'include': '#type'
      }
    ]


  'args':
    'comment': 'Match the arguments in a function'
    'patterns': [
      {
        'match': '[_a-zA-Z\\$][\\w\\$]*(?=\\??\\s*[,\\)])'
        'name': 'variable.parameter.function.ts'
      }
      {
        'begin': '([_a-zA-Z\\$][\\w\\$]*)\\??\\s*:\\s*'
        'beginCaptures':
          '1':
            'name': 'variable.parameter.function.ts'
        'end': '(?=\\s*[,\\)])'
        'patterns': [
          {
            'include': '#type'
          }
        ]
      }
    ]
